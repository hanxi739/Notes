#### 1.数据库为什么查询很慢？

##### 一、应用的问题

数据库表设计不合理，应该加索引的字段没有加索引
查询sql语句是不是编写不合理，查询的时候没有加索引
查询sql语句的条件加了索引，但是查询的时候没有命中索引，比如：前缀匹配失效、条件字段做了类型转换或者使用了函数、使用了范围查询等；使用 explain 查看索引命中情况 ；
join的表太多了？？？
数据库中的单表的数据量达到了多少？1000万？5000万？是不是考虑分库分表；参考
分库分表怎么选取分片键？
分库分表后怎么查询？
分库分表的算法？一致性hash环？
分库分表的节点个数怎么考虑
程序异常导致大量数据库连接不能释放，一直被占用？

##### 二、数据库的问题

参数优化，连接池资源不够用了
数据库所在的硬件资源情况：当查询慢的时候，内存占了多少？mysql磁盘IO是不是被其它应用共享且占用高？cpu是不是有负载？
硬件资源本身不够>加资源
硬件资源因为和其它进程共享，导致资源不够，可以考虑做资源隔离
硬件资源性能不足，比如磁盘可以考虑换成SSD
网络资源
应用连接数据库的网络是不是抖动，延时较高

##### 三、请求量太大

如果数据量真的炒鸡大，分库分表已经不能满足查询了，考虑将热点数据在redis做缓存
应用架构调整，把缓存模块加进去
如果已经加了缓存还是慢，会不会是缓存雪崩了？击穿了？缓存命中率低？
缓存任然不能满足查询要求，比如很多字段的查询，可以将查询字段放到ES等大数据组件中，先查ES，ES拿到数据主键id再到MySQL中查询
用户请求突然增加，导致查询变慢
上有系统出现bug，导致循环调用接口做查询，这个时候是不是考虑异常情况限流
用户请求真的是大量增加了，公司发展迅猛

原文链接：https://blog.csdn.net/cqupt2012214390/article/details/106620459



##### 数据库查询偶尔很慢：

###### 1.**数据库正在刷新脏页。**

当我们输入一条新数据的时候，或者要更新一条数据的时候，我们知道数据库会在 内存 中把对应的字段值更新掉。但是更新之后，这些更新的字段并不是同步写入磁盘进行持久化操作，而是记录到redo log 日志里边，等待空闲的时候在写入磁盘，但是如果数据库一直在操作，redo log日志 存贮就达到上限，数据库就会全心把redo log 日志里的内容写入磁盘，而这个操作就导致我们的SQL查询变慢。

###### **2.数据库连接的自然数满**

出现这种错误明显就是 mysql_connect 之后忘记 mysql_close；当大量的connect之后，就会出现Too many connections的错误，mysql默认的连接为100个，而什么情况下会出现这种错误呢？正常的mysql_connect 之后调用 mysql_close()关闭连接。但在连接错误时，会者mysql_real_query()出现错误退出时，可能忘mysql_close()

###### **3.拿不到锁**

我们要执行的SQL，碰巧碰到别人也在用此条数据，就只能等待了。判断是否真的在等待锁，可以用show processlist 命令来查询当前状态。

##### 一直慢的原因

首先考虑应用的问题：

###### 数据表是否建了索引

###### 索引是否合适。

**应该将经常作为查询条件、唯一性强、更新不频繁的字段作为索引**；同时在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

###### 查询的时候没有索引失效。

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

索引的顺序应该让选择性最强的索引放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

以上问题可以通过explain工具进行分析。使用 explain 查询和分析SQl的执行记录，可以进行sql的性能优化！

explain 可以帮助我们分析 select 语句，让我们知道查询效率低下的原因，从而改进我们的查询

```
id：查询序列号。表示查询中执行 select 子句或操作表的顺序，id 值越大优先级越高，越先被执行。id 相同，执行顺序由上至下。 
select_type：查询类型
table：输出行所引用的表
possible_keys：指出 MySQL 能在该表中使用哪些索引有助于查询。如果为空，说明没有可用的索引  
key：MySQL 实际从 possible_key 选择使用的索引。
key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好 
ref：显示索引的哪一列被使用了 
rows：MYSQL 认为必须检查的用来返回请求数据的d行数
```

```mysql
show index from table
```

![image-20210323204058594](C:\Users\73933\Desktop\韩茜找实习\学习\CS-Notes-master\notes\数据库\pics-DB\INDEX.png)

###### 数据库是不是太大了，或许可以考虑分库分表。

再考虑数据库服务器：

数据库所在的硬件资源情况：当查询慢的时候，内存占了多少？mysql磁盘IO是不是被其它应用共享且占用高？cpu是不是有负载？

如果数据量真的炒鸡大，分库分表已经不能满足查询了，考虑将热点数据在redis做缓存，应用架构调整，把缓存模块加进去。

#### 2.数据库的回表查询是什么？

这先要从InnoDB的索引实现说起，InnoDB有两大类索引：

聚集索引(clustered index)

普通索引(secondary index) 

InnoDB聚集索引和普通索引有什么差异？ 

InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：

（1）如果表定义了PK，则PK就是聚集索引；

（2）如果表没有定义PK，则第一个not NULL unique列是聚集索引；

（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；

**nnoDB普通索引的叶子节点存储主键值。注意，不是存储行记录头指针，MyISAM的索引叶子节点存储记录指针。**

普通索引的查询过程为：

1. 先扫描通过普通索引建立的B+树，找到叶子节点存储的主键值；
2. 再扫描聚集索引的B+树，找到该对应的完整记录。

这就是所谓的**回表查询**，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。

#### 3.两段锁协议？

两段锁协议是保证并行事务可串行化的方法。可以证明，若并发执行的所有事务均遵守两段锁协议，则这些事务的任何并发调度策略都是可串行化的。

所谓“两段”锁的含义是，事务分为两个阶段
第一阶段是获得封锁，也称为扩展阶段。这在阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁
第二阶段是释放封锁，也称为收缩阶段。在这阶段，事务可以释放任何数据项上的任何类型的琐，但是不能再申请任何琐

**另外要注意两段锁协议和防止死锁的一次封锁法的异同**
一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议
但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁

#### 数据库锁的类型

###### 互斥锁(X锁)

又称写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。

###### 共享锁(S锁)

共享锁(S锁)又称为读锁。若事务T对数据对象A加上S锁，则事务可以T读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其它事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

###### 更新锁（U锁）

除X锁、S锁两种所之外，又增加了U锁。事务在进行更新时，一般都需要先读出旧的内容，在内存中修改后，再将修改后的内容写回, 在此过程中，除了最后写回阶段，被更新的数据对象仍然可被其他事务访问
U锁就是为此目的设置的
事务在需要(或有可能)更新一个数据对象时，首先申请对它的U锁，数据对象加了U锁后，仍允许其他事务对其加S锁，待最后需要写入时，事务再申请将U锁升级为X锁。由于不必在事务执行的全过程中加X锁，所以进一步提高了系统的并发度 。

#### 不可重复读

不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。具体地讲，不可重复读包括三种情况:
事务T1读取某一数据后，事务T2对其做了修改，当事务1再次读该数据时，得到与前一次不同的值。例如T1读取B=100进行运算，T2读取同一数据B，对其进行修改后将B=200写回数据库。T1为了对读取值校对重读B，B已为200，与第一次读取值不一致
事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神密地消失了
事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现神密地多了一些记录,这种现象又称为“读幻像行”

#### 数据库的隔离级别和实现方式

MySQL的MVCC讲的很准确 ：https://blog.csdn.net/Waves___/article/details/105295060

undo log

Undo log中存储的是老版本数据，当一个事务需要读取记录行时，如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本。
        大多数对数据的变更操作包括 insert/update/delete，在InnoDB里，undo log分为如下两类：
        ①insert undo log : 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。
        ②update undo log : 事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。



在innodb中，创建一个新事务后，执行第一个select语句的时候，innodb会创建一个快照（read view），快照中会保存系统当前不应该被本事务看到的其他活跃事务id列表（即trx_ids）。当用户在这个事务中要读取某个记录行的时候，innodb会将该记录行的DB_TRX_ID与该Read View中的一些变量进行比较，判断是否满足可见性条件。

​    假设当前事务要读取某一个记录行，该记录行的DB_TRX_ID（即最新修改该行的事务ID）为trx_id，Read View的活跃事务列表trx_ids中最早的事务ID为up_limit_id，将在生成这个Read Vew时系统出现过的最大的事务ID+1记为low_limit_id（即还未分配的事务ID）。

具体的比较算法如下:

        1. 如果 trx_id < up_limit_id, 那么表明“最新修改该行的事务”在“当前事务”创建快照之前就提交了，所以该记录行的值对当前事务是可见的。跳到步骤5。
    
        2. 如果 trx_id >= low_limit_id, 那么表明“最新修改该行的事务”在“当前事务”创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤4。
    
        3. 如果 up_limit_id <= trx_id < low_limit_id, 表明“最新修改该行的事务”在“当前事务”创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表trx_ids进行查找（源码中是用的二分查找，因为是有序的）：
    
            (1) 如果在活跃事务列表trx_ids中能找到 id 为 trx_id 的事务，表明①在“当前事务”创建快照前，“该记录行的值”被“id为trx_id的事务”修改了，但没有提交；或者②在“当前事务”创建快照后，“该记录行的值”被“id为trx_id的事务”修改了（不管有无提交）；这些情况下，这个记录行的值对当前事务都是不可见的，跳到步骤4；
    
            (2)在活跃事务列表中找不到，则表明“id为trx_id的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见，跳到步骤5。
    
        4. 在该记录行的 DB_ROLL_PTR 指针所指向的undo log回滚段中，取出最新的的旧事务号DB_TRX_ID, 将它赋给trx_id，然后跳到步骤1重新开始判断。
    
        5. 将该可见行的值返回。
##### 未提交读

事务中的修改，即使没有提交，对其它事务也是可见的。总是读取最新的数据，要求太低，无需控制吧？

##### 已提交读

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

​    ②在innodb中的Read Committed级别, 事务在begin之后，执行每条select（读操作）语句时，快照会被重置，即会重新创建一个快照(read view)。

##### 可重复读

​     ①在innodb中的Repeatable Read级别, 只有事务在begin之后，执行第一条select（读操作）时, 才会创建一个快照(read view)，将当前系统中活跃的其他事务记录起来；并且事务之后都是使用的这个快照，不会重新创建，直到事务结束。

##### 可串行化

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

行级锁的实现：

**InnoDB 通过给索引上的索引记录加锁的方式实现行级锁**。具体来说，InnoDB 实现了三种行锁的算法：记录锁（Record Lock）、间隙锁（Gap Lock）和 Next-key 锁（Next-key Lock）。

**记录锁（Record Lock）是针对索引记录（index record）的锁定**。例如，`SELECT * FROM t WHERE id = 1 FOR UPDATE;`会阻止其他事务对表 t 中 id = 1 的数据执行插入、更新，以及删除操作。

**间隙锁（Gap Lock）**锁定索引之间的间隙，但是不包含索引本身。例如，SELECT * FROM t WHERE c1 BETWEEN 1 and 10 FOR UPDATE;会阻止其他事务将 1 到 10 之间的任何值插入到 c1 字段中，即使该列不存在这样的数据；因为这些值都会被锁定。
**Next-key 锁（Next-key Lock）**相当于一个索引记录锁加上该记录之前的一个间隙锁。

InnoDB 实现行级锁的方式如下：当搜索或扫描表索引时，在遇到的索引记录上设置共享锁或排它锁。因此，InnoDB 行级锁实际上是索引记录锁。一个索引记录上的 next-key 锁也会影响该索引记录之前的“间隙”，如果一个会话在索引中的记录 R 上有共享锁或排它锁，则另一个会话不能在 R 之前的间隙中插入新的索引记录。

假设一个索引中包含数据 10、11、13 和 20。该索引中可能的 next-key 锁包含以下范围，其中圆括号表示排除端点值，方括号表示包含端点值：

原文链接：https://blog.csdn.net/horses/article/details/103324323

- **区别：**

  \1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

  \2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  

  \3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 

  \4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    

  \5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

  **如何选择：**

  \1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；

  \2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。

  \3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；

   \4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。

进程和线程的区别：

1、进程是资源分配的最小单位，线程是调度和程序执行的最小单位；


2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。


3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。

4、但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

#### 进程和线程的区别：

1.最小单位。

2.创建与切换开销。

3通信方式方式，各有利弊

4

#### 进程间通信的方式：

信号：软件中断，用于在进程间传递异步信号。但是数据量小。

管道：ls -l |grep kvm  ls进程通过管道把结果传给grep进程进行过滤。不能向多个接收者传递数据。管道中的数据被当作字节流，无法识别信息的边界。

pipe 匿名管道只能用于父子进程间通信。

命名管道：可以用于没有亲缘关系的进程通信。



**管道pipe：**管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
**命名管道FIFO：**有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
**消息队列MessageQueue**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
**共享存储SharedMemory：**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
**信号量Semaphore：**信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
**套接字Socket：**套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
**信号 ( sinal ) ：** 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。



![image-20210323224543874](pics-DB\signal.png)

![image-20210323224854925](pics-DB\pipe.png)

![image-20210323230401318](pics-DB\FIFIO.png)

#### 同步异步、阻塞非阻塞

背景：进程A调用方法B时：

阻塞与非阻塞：调用其他方法的进程是被挂起，还是继续执行其他工作。

同步与非同步：被调用的方法执行结束后是否会通知调用它的进程。

###### 同步：

A调用B，B处理直到获得结果，才返回给A。
 需要调用者一直等待和确认调用结果是否返回， 然后继续往下执行。

###### 异步：

A调用B，B直接返回。无需等待结果，B通过状态，通知等来通知A或回调函数来处理。
 调用结果返回时， 会以消息或回调的方式通知调用者。

这里我们可以看出，同步和异步是一种 消息通知机制，是相对于被调用者而言的。

###### 阻塞：

A调用B，A被挂起直到B返回结果给A，A继续执行。
 调用结果返回前，当前进程挂起不能够处理其他任务，一直等待调用结果返回。

###### 非阻塞：

A调用B，A不会被挂起，A可以执行其他操作。
 调用结果返回前，当前进程不挂起， 可以去处理其他任务。

###### 同步阻塞：

调用结果返回前，进程挂起，等待调用结果返回。效率低。

###### 异步阻塞：

虽然调用结果返回会通知进程，但是调用结果返回前，当前进程挂起。所以同样效率低。

###### 同步非阻塞：

调用结果返回前不会阻塞当前进程，当前进程可以去做其他事情，但是需要通过轮询来确认调用结果是否返回，耗cpu性能，效率会比 1，2 高点。但是还不够高

###### 异步非阻塞：

调用结果返回前当前进程可以继续做其他事情，函数调用完成后会以回调或者消息的方式通知进程。效率最高。