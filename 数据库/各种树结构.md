### 基本概念

节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推。
节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度
**树的深度：一棵树中节点的最大深度就是树的深度，也称为高度**
父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点
子节点：一个节点含有的子树的根节点称为该节点的子节点
节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推
兄弟节点：拥有共同父节点的节点互称为兄弟节点
度：节点的子树数目就是节点的度
叶子节点：度为零的节点就是叶子节点
祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）
后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）
森林：m颗互不相交的树构成的集合就是森林
————————————————
版权声明：本文为CSDN博主「zeling1005」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u014532217/article/details/79118023



节点的深度深度是从上往下数的，高度是从下往上数的，深度和高度都涉及到节点的层数(经过学习发现，**深度、高度概念在不同的教材中有不同的定义，主要看高度深度的初值为几，有的为0，有的为1**)。是根节点到这个节点所经历的边的个数

　　　　　　　　　　　节点的高度是该节点到叶子节点的最长路径（边数）

　　　　　　　　　　　树的高度等于根节点的高度

![image-20210311110702196](tree-pics\tree.png)

#### 无序树

树的任意节点的子节点没有顺序关系。

#### 有序树

树的任意节点的子节点有顺序关系。

#### 二叉树

树的任意节点至多包含两棵子树。

##### 二叉树遍历

前序遍历（前根遍历）：根——>左——>右

中序遍历（中根遍历）：左——>根——>右

后序遍历（后根遍历）：左——>右——>根

已知前序和中序，求后序问题，  前序 ABDGCEFH    中序 DGBAECHF

解法：根据前序、中序综合判断画出树的节点图，然后再写后序遍历：DGBEHFCA

（前序和中序的子树也满足前序或中序的规则）
二叉树的深度优先遍历（DFS）与广度优先遍历（BFS）

######  DFS深度优先遍历

从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。利用数据结构“栈”，父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。递归遍历全部节点。

###### BFS广度优先遍历

从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。利用数据结构“队列”，父节点入队，父节点出队列，先左子节点入队，后右子节点入队。递归遍历全部节点。

叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。

#### 完全二叉树

对于一颗二叉树，假设其深度为d（d>1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
PS：这里的满二叉树和完全二叉树取的是国内的定义，国外的定义不一样，有兴趣的可以去看看国外的定义。

#### 二叉查找树（二叉搜索树、BST）

若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。

#### 平衡二叉树（AVL）

它是一棵空树或

它的左右两个子树的高度差的绝对值不超过1；

并且左右两个子树都是一棵平衡二叉树；

同时，平衡二叉树必定是二叉搜索树。

这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

平衡二叉树大部分操作和二叉查找树类似，主要不同在于插入删除的时候平衡二叉树的平衡可能被改变，并且只有从那些插入点到根结点的路径上的结点的平衡性可能被改变，因为只有这些结点的子树可能变化。

##### AVL树的插入与删除

**平衡二叉树不平衡的情形：**

把需要重新平衡的结点叫做α，由于任意两个结点最多只有两个儿子，因此高度不平衡时，α结点的两颗子树的高度相差2.容易看出，这种不平衡可能出现在下面4中情况中：

1.对α的左儿子的左子树进行一次插入

2.对α的左儿子的右子树进行一次插入

3.对α的右儿子的左子树进行一次插入

4.对α的右儿子的右子树进行一次插入

![image-20210311111609444](tree-pics\AVL树的旋转.png)

**调整措施：**

**一、单旋转**

**![img](https://images2015.cnblogs.com/blog/805461/201601/805461-20160127220751410-639565779.jpg)**

 

上图是左左的情况，k2结点不满足平衡性，它的左子树k1比右子树z深两层，k1子树中更深的是k1的左子树x，因此属于左左情况。

为了恢复平衡，我们把x上移一层，并把z下移一层，但此时实际已经超出了AVL树的性质要求。为此，重新安排结点以形成一颗等价的树。为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。

这种情况称为单旋转。

 

**二、双旋转**

对于左右和右左两种情况，单旋转不能解决问题，要经过两次旋转。

![img](https://images2015.cnblogs.com/blog/805461/201601/805461-20160127221858707-881408395.jpg)

对于上图情况，为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。

 

**AVL树的删除操作：**

同插入操作一样，删除结点时也有可能破坏平衡性，这就要求我们删除的时候要进行平衡性调整。

删除分为以下几种情况：

首先在整个二叉树中搜索要删除的结点，如果没搜索到直接返回不作处理，否则执行以下操作：

1.要删除的节点是当前根节点T。

如果左右子树都非空。在高度较大的子树中实施删除操作。

分两种情况：

(1)、左子树高度大于右子树高度，将左子树中最大的那个元素赋给当前根节点，然后删除左子树中元素值最大的那个节点。

(1)、左子树高度小于右子树高度，将右子树中最小的那个元素赋给当前根节点，然后删除右子树中元素值最小的那个节点。

如果左右子树中有一个为空，那么直接用那个非空子树或者是NULL替换当前根节点即可。

2、要删除的节点元素值小于当前根节点T值，在左子树中进行删除。

递归调用，在左子树中实施删除。

这个是需要判断当前根节点是否仍然满足平衡条件，

如果满足平衡条件，只需要更新当前根节点T的高度信息。

否则，需要进行旋转调整：

如果T的左子节点的左子树的高度大于T的左子节点的右子树的高度，进行相应的单旋转。否则进行双旋转。

3、要删除的节点元素值大于当前根节点T值，在右子树中进行删除。



#### 霍夫曼树

带权路径最短的二叉树称为哈夫曼树或最优二叉树。

#### 红黑树

红黑树是一颗特殊的二叉查找树，除了二叉查找树的要求外，它还具有以下特性：

1. 每个节点或者是黑色，或者是红色。
2. 根节点是黑色。
3. 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！
4. 树中不存在两个相邻的红色节点（如果一个节点是红色的，则它的子节点必须是黑色的。）
5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。





另一种说法：

1. 每一个结点都有一个颜色，要么为红色，要么为黑色；
2. 树的根结点为黑色；
3. 树中不存在两个相邻的红色结点（即红色结点的父结点和孩子结点均不能是红色）；
4. 从任意一个结点（包括根结点）到其任何后代 NULL 结点（默认是黑色的）的每条路径都具有相同数量的黑色结点。

**什么是一颗红黑树的黑高（Black Height)?**

在一颗红黑树中，从某个结点 **x** 出发（不包含该结点）到达一个叶结点的任意一条简单路径上包含的黑色结点的数目称为 **黑高** ，记为 **bh(x)** 。

红黑树的黑高则为其根结点的黑高。根据红黑树的性质 3、4，一颗红黑树的黑高 **bh >= h/2**

**为什么要有红黑树？**

大多数二叉排序树BST的操作（查找、最大值、最小值、插入、删除等等）都是 ![[公式]](https://www.zhihu.com/equation?tex=O%28h%29) 的时间复杂度，h 为树的高度。但是对于斜树而言（BST极端情况下出现），BST的这些操作的时间复杂度将达到  ![[公式]](https://www.zhihu.com/equation?tex=O%28n%29) 。为了保证BST的所有操作的时间复杂度的上限为  ![[公式]](https://www.zhihu.com/equation?tex=O%28logn%29) ，就要想办法把一颗BST树的高度一直维持在![[公式]](https://www.zhihu.com/equation?tex=logn)，而红黑树就做到了这一点，红黑树的高度始终都维持在![[公式]](https://www.zhihu.com/equation?tex=logn)，n 为树中的顶点数目。



##### **红黑树RBT与平衡二叉树AVL比较：**

AVL 树比红黑树更加平衡，但AVL树在插入和删除的时候也会存在大量的旋转操作。所以当你的应用涉及到频繁的插入和删除操作，切记放弃AVL树，选择性能更好的红黑树；当然，如果你的应用中涉及的插入和删除操作并不频繁，而是查找操作相对更频繁，那么就优先选择 AVL 树进行实现。

**引理：一棵有n个内部结点的红黑树的高度 h <= 2lg(n+1)。**

关于算法导论中的证明，就不再这里显摆了，我们用一种更直观的方式来看一下这个问题。

首先我们将下图中的所有红色结点合并到其黑色父结点

![img](https://pic4.zhimg.com/50/v2-50852586b14af581b0ad605ab9e31c46_hd.jpg?source=1940ef5c)![img](https://pic4.zhimg.com/80/v2-50852586b14af581b0ad605ab9e31c46_720w.jpg?source=1940ef5c)

合并动画演示：

![img](https://pic2.zhimg.com/50/v2-4753fa6410f8c5de4d1f31a8ce53e00c_hd.webp?source=1940ef5c)

合并后的结果：

![img](https://pic2.zhimg.com/50/v2-51c6350b8183049ca8bc2e538e4ea85c_hd.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-51c6350b8183049ca8bc2e538e4ea85c_720w.jpg?source=1940ef5c)

也就是刚才的合并产生了一颗 2-3-4 树，这棵树中的每一个结点有2、3 或者 4 个孩子结点。而一颗 2-3-4 树的叶结点有着相同的深度 ![[公式]](https://www.zhihu.com/equation?tex=h%5E%7B%27%7D) .

![img](https://pic1.zhimg.com/50/v2-ff10275a8bc909f4cd2f1400f9d563de_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-ff10275a8bc909f4cd2f1400f9d563de_720w.jpg?source=1940ef5c)

由于从根结点到任何一个叶结点的路径上至多只有高度 ![[公式]](https://www.zhihu.com/equation?tex=h) 的一半的红色结点数目，所以可以得到    的结论。

对于一颗有 ![[公式]](https://www.zhihu.com/equation?tex=n%2B1) 个叶子结点的2-3-4 树而言，可以依次得到如下结论：

1.  ![[公式]](https://www.zhihu.com/equation?tex=n%2B1%5Cge2%5E%7Bh%5E%7B%27%7D%7D) 
2.  ![[公式]](https://www.zhihu.com/equation?tex=log%28n%2B1%29+%5Cge+h%5E%7B%27%7D+%5Cge+h%2F2) 
3.  ![[公式]](https://www.zhihu.com/equation?tex=h+%5Cle+2log%28n%2B1%29) 

所以对于一颗有  ![[公式]](https://www.zhihu.com/equation?tex=n) 个结点的红黑树而言，不论查找、删除、查找和最大值、最小值等等的时间复杂度都是  ![[公式]](https://www.zhihu.com/equation?tex=O%28logn%29) .

**红黑树有什么应用呢？** 

1. 大多数自平衡BST(self-balancing BST) 库函数都是用红黑树实现的，比如C++中的map 和 set （或者 Java 中的 TreeSet 和 TreeMap）。
2. 红黑树也用于实现 Linux 操作系统的 CPU 调度。完全公平调度（Completely Fair Scheduler）使用的就是红黑树。



作者：程序员景禹
链接：https://www.zhihu.com/question/30317295/answer/1246106121
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### 红黑树的插入过程：

https://www.cnblogs.com/chinxi/p/12174162.html

#### B树

是一种多路搜索树（并不是二叉的），并且在插入和删除中需要进行节点拆分或者合并以维持平衡性，满足如下特点：

1. 根结点的儿子数为[2, M]；
2. 任意除根结点外的非叶子结点的子节点数是[M/2, M]且M>2；   
3. 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）；
4. 非叶子结点的关键字个数=指向儿子的指针个数-1（有关键字个数+1个取值范围）；
5. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；    
6. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；【前闭后开】    
7. 所有叶子结点位于同一层；

如：（M=3）：

![image-20210311120444431](tree-pics\B-tree.png)

 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

B-树的特性：    

1.关键字集合分布在整颗树中；    

2.任何一个关键字出现且只出现在一个结点中；    

3.搜索有可能在非叶子结点结束；    

4.其搜索性能等价于在关键字全集内做一次二分查找；    

5.自动层次控制；    

由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：



![image-20210311120537176](tree-pics\B2.png)

其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并。

B树的插入过程：https://www.cnblogs.com/linhaostudy/archive/2019/09/10/11497320.html

#### **B+树**    

B+树是B-树的变体，也是一种多路搜索树：    

1.其定义基本与B-树同，除了：    

2.非叶子结点的子树指针与关键字个数相同；    

3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；    

4.为所有叶子结点增加一个链指针；    

5.所有关键字都在叶子结点出现；    如：（M=3）

![image-20210311120640761](tree-pics\B+Tree.png)

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；   

 B+的特性：    

1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；    

2.不可能在非叶子结点命中；    

3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；    

4.更适合文件索引系统；为所有叶子结点增加一个链指针；   

#### B*树

是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；