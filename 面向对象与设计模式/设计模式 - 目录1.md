# 一、前言

设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。

# 二、创建型

- [单例.md](notes/设计模式%20%20-%20单例.md)
- [简单工厂.md](notes/设计模式%20-%20简单工厂.md)
- [工厂方法.md](notes/设计模式%20-%20工厂方法.md)
- [抽象工厂.md](notes/设计模式%20-%20抽象工厂.md)
- [生成器.md](notes/设计模式%20-%20生成器.md)
- [原型模式.md](notes/设计模式%20-%20原型模式.md)

##### 单例模式

确保一个类只有一个实例，并提供该实例的全局访问点。

使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。

私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png"/> </div><br>

##### 简单工厂模式

简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类根据传入的参数来决定应该用哪个具体子类来实例化。

产生背景：

如果某个类的构造函数包含很多初始化操作，如查看配置文件、查询数据库等，构造函数就会很冗长，降低了程序的可读性，可以专门构建一个负责对象创建的类——工厂类，把要创建的类对象的初始化操作放在工厂类的方法中，提高主要代码的可读性。

这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png"/> </div><br>

##### 工厂方法模式

定义了一个创建对象的接口，但由子类决定要实例化哪个类。**工厂方法把实例化操作推迟到子类。**

在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。

下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png"/> </div><br>

###### Implementation

```java
public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething() {
        Product product = factoryMethod();
        // do something with the product
    }
}
```

```java
public class ConcreteFactory extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct();
    }
}
```

```java
public class ConcreteFactory1 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct1();
    }
}
```

```java
public class ConcreteFactory2 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct2();
    }
}
```

##### 抽象工厂



# 三、行为型

- [责任链.md](notes/设计模式%20-%20责任链.md)
- [命令.md](notes/设计模式%20-%20命令.md)
- [解释器.md](notes/设计模式%20-%20解释器.md)
- [迭代器.md](notes/设计模式%20-%20迭代器.md)
- [中介者.md](notes/设计模式%20-%20中介者.md)
- [备忘录.md](notes/设计模式%20-%20备忘录.md)
- [观察者.md](notes/设计模式%20-%20观察者.md)
- [状态.md](notes/设计模式%20-%20状态.md)
- [策略.md](notes/设计模式%20-%20策略.md)
- [模板方法.md](notes/设计模式%20-%20模板方法.md)
- [访问者.md](notes/设计模式%20-%20访问者.md)
- [空对象.md](notes/设计模式%20-%20空对象.md)

# 四、结构型

- [适配器.md](notes/设计模式%20-%20适配器.md)
- [桥接.md](notes/设计模式%20-%20桥接.md)
- [组合.md](notes/设计模式%20-%20组合.md)
- [装饰.md](notes/设计模式%20-%20装饰.md)
- [外观.md](notes/设计模式%20-%20外观.md)
- [享元.md](notes/设计模式%20-%20享元.md)
- [代理.md](notes/设计模式%20-%20代理.md)

# 参考资料

- 弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.
- Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.
- Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.
- [Design Patterns](http://www.oodesign.com/)
- [Design patterns implemented in Java](http://java-design-patterns.com/)
- [The breakdown of design patterns in JDK](http://www.programering.com/a/MTNxAzMwATY.html)
